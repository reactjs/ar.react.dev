---
id: glossary
title: المصطلحات في React
layout: docs
category: Reference
permalink: docs/glossary.html

---

## التطبيق أحادي الصفحة {#single-page-application}

التطبيق وحيد الصفحة (Single-page Application) هو التطبيق الذي يُحمِّل صفحة HTML واحدة وكل ملحقاتها الضرورية (مثل CSS و JavaScript) المطلوبة لكي يعمل التطبيق. لا تتطلّب أيّة تفاعلات مع الصفحة أو الصفحات اللاحقة أي عودة للخادم مرّة أخرى، ممّا يعني عدم إعادة تحميل الصفحة.

بالرغم من قدرتك على بناء تطبيق وحيد الصفحة في React فهو ليس أمرًا ضروريًّا. يُمكِن أيضًا استخدام React لتحسين أجزاء صغيرة من الموقع مع الحصول على تفاعليّة أكبر. يُمكِن للشيفرة المكتوبة باستخدام React أن تتواجد بشكل مشترك مع التنسيق المُصيَّر على الخادم باستخدام PHP أو أي مكتبات من طرف الخادم الأخرى. وفي الحقيقة هذه هي بالضبط طريقة استخدام React في Facebook.

## ES6, ES2015, ES2016, إلخ {#es6-es2015-es2016-etc}

تُشير هذه الاختصارات إلى أحدث إصدارات من معايير مواصفة اللغة ECMAScript، والتي تكون لغة JavaScript تنفيذًا لها. يتضمّن الإصدار ES6 (يُدعى أيضًا ES2015) إضافات عديدة إلى الإصدارات السابقة مثل الدوال السهمية، والأصناف،والقوالب الحرفية، والتصريحان `let` و `const`. بإمكانك تعلّم المزيد حول الإصدارات المحدّدة [من هنا](https://en.wikipedia.org/wiki/ECMAScript#Versions).

## المصرفات {#compilers}

يأخذ مُصرِّف JavaScript شيفرة في JavaScript ويحوّلها ويُعيد شيفرة JavaScript بصياغة أخرى. أشيع حالة استخدام هي أن نأخذ صياغة ES6 و نحولها إلى صياغة أقدم لكي تتمكن المتصفحات القديمة من تفسيرها. المُصرِّف الأكثر استخدامًا مع React هو. [Babel](https://babeljs.io/).

## المُحزِّمات (Bundlers) {#bundlers}

تأخذ المُحزِّمات شيفرة CSS و JavaScript المكتوبة كوحدات منفصلة (عادةً المئات منها)، وتجمعها معًا في بضعة ملفّات مُحسَّنة الأداء لأجل المتصفحات. من المُحزِّمات الأشيع استخدامًا في تطبيقات React نجد [Webpack](https://webpack.js.org/) و [Browserify](http://browserify.org/).

## مدير الحزم {#package-managers}

مدير الحزم هو الأداة التي تسمح لك بإدارة الاعتماديّات في مشروعك. أشيع مُديرا حزم مستخدمان في React هما [npm](https://www.npmjs.com/) و [Yarn](https://yarnpkg.com/) وكلاهما عبارة عن واجهة لنفس مُسجّل حزم `npm`.

## شبكة توزيع المحتوى CDN {#cdn}

ترمز CDN إلى شبكة توزيع المحتوى (Content Delivery Network). تُوزِّع هذه الشبكات محتوى ثابت ومُخبَّأ من شبكة من الخوادم عبر العالم.

## JSX {#jsx}

JSX هي عبارة عن صياغة ممتدة إلى JavaScript، وهي مشابهة للغة القوالب ولكنّها تملك القوة الكاملة للغة JavaScript. تُصرَّف JSX إلى نداءات للتابع `React.createElement()`‎ والذي يُعيد كائنات JavaScript مُجرَّدة تُدعى عناصر React. للحصول على مقدمة حول JSX انظر هنا، وللمزيد من المعلومات المفصلة حول JSX [انظر هنا](/docs/introducing-jsx.html) and find a more in-depth tutorial on JSX [here](/docs/jsx-in-depth.html).

تستخدم React DOM اتفاقية تسمية الخاصيّات بطريقة camelCase بدلًا من أسماء خاصيّات HTML. على سبيل المثال تُصبِح الخاصيّة `tabindex` على الشكل `tabIndex` في JSX. تُكتَب أيضًا الخاصيّة `class` على الشكل `className` لأنّ الكلمة `class` هي كلمة محجوزة في JavaScript:

```js
const name = 'Clementine';
ReactDOM.render(
  <h1 className="hello">My name is {name}!</h1>,
  document.getElementById('root')
);
```  

## [العناصر](/docs/rendering-elements.html) {#elements}

عناصر React هي وحدات بناء تطبيقات React. قد يخلط المرء بين العناصر ومفهوم أكثر شيوعًا وهو المكوّنات. يصف العنصر ما ترغب برؤيته على الشاشة، وتكون عناصر React غير قابلة للتعديل:

```js
const element = <h1>Hello, world</h1>;
```

لا تُستخدَم العناصر بشكلٍ مباشر عادةً، بل تُعاد من المكوّنات.

## [المكوّنات](/docs/components-and-props.html) {#components}

مكوّنات React هي قطع صغيرة وقابلة لإعادة الاستخدام من الشيفرة والتي تُعيد عناصر React المطلوب تصييرها في الصفحة. أبسط شكل لمكوّن React هو دالة JavaScript مجرّدة والتي تُعيد عنصر React:

```js
function Welcome(props) {
  return <h1>Hello, {props.name}</h1>;
}
```

قد تكون المكوّنات أصناف ES6 أيضًا:

```js
class Welcome extends React.Component {
  render() {
    return <h1>Hello, {this.props.name}</h1>;
  }
}
```

يُمكِن تقسيم المكوّنات إلى قطع مستقلة وظيفيًّا يُمكِن استخدامها ضمن مكوّنات أخرى. تستطيع المكوّنات إعادة مكوّنات أخرى، ومصفوفات، وسلاسل نصيّة، وأعداد. القاعدة هنا إن كان جزء من واجهة المستخدم لديك مُستخدمًا عدّة مرات (مثل الأزرار ولوحة التحكم والصورة الرمزية)، أو كان مُعقّدًا بحد ذاته (تطبيق، تعليق) فهو مرشّح جيّد ليكون مكوّن قابل لإعادة الاستخدام. يجب أن تبدأ أسماء المكوّنات دائمًا بحرف كبير (`<Wrapper/>` **وليس** `<wrapper/>`). انظر إلى [هذا التوثيق](/docs/components-and-props.html#rendering-a-component) للمزيد من المعلومات حول تصيير المكوّنات.

### [`الخاصيّات`](/docs/components-and-props.html) {#props}

الخاصيّات `props` هي مُدخَلات في مكوّنات React، أي هي عبارة عن بيانات تُمرَّر للمستوى الأدنى من المكوّن الأب إلى المكوّن الابن.

تذكّر أنّ الخاصيّات قابلة للقراءة فقط ولا يجب تعديلها بأي طريقة:

```js
// Wrong!
props.number = 42;
```

إن احتجت لتعديل بعض القيم استجابةً لمدخلات المستخدم أو الردود القادمة من الشبكة، فاستخدم الحالة `state` بدلًا من ذلك.

### `props.children` {#propschildren}

يكون `props.children` متوفرًا في كل مكوّن، وهو يحتوي على المحتوى الموجود بين وسم الفتح ووسم الإغلاق للمكوّن، على سبيل المثال:

```js
<Welcome>Hello world!</Welcome>
```

تكون السلسلة النصيّة `Hello world!` متوفرة ضمن `props.children` في المكوّن `Welcome`:

```js
function Welcome(props) {
  return <p>{props.children}</p>;
}
```

ولأجل المكوّنات المُعرَّفة كأصناف استخدم `this.props.children`:

```js
class Welcome extends React.Component {
  render() {
    return <p>{this.props.children}</p>;
  }
}
```

### [`الحالة`](/docs/state-and-lifecycle.html#adding-local-state-to-a-class) {#state}

يحتاج المكوّن للحالة `state` عندما تتغيّر بعض البيانات المرتبطة معه عبر الزمن. على سبيل المثال يحتاج مكوّن مربع الاختيار `Checkbox` إلى وجود `isChecked` ضمن حالته، ويحتاج مكوّن شريط الأخبار `NewsFeed` إلى تتبّع جميع المنشورات المُحضَرة `fetchedPosts` في حالته.

الفرق الأكبر بين الحالة والخاصيّات هو تمرير الخاصيّات من المكوّن الأب، أمّا الحالة فتكون مُدارة من قبل المكوّن نفسه. لا يستطيع المكوّن تغيير خاصيّاته ولكن يستطيع تغيير حالته. لفعل ذلك يجب عليه استدعاء التابع `this.setState()`‎. يُمكِن فقط للمكوّنات المُعرَّفة كأصناف أن تمتلك حالة.

لكل قطعة محددة من البيانات المتغيرة يجب وجود مكوّن واحد يمتلكها في حالته. لا تحاول مزامنة الحالات لمكوّنين مختلفين، وبدلًا من ذلك ارفع الحالة إلى أقرب مكوّن أب مشترك لهما ومرّرها للمستويات الأدنى كخاصيّات لكليهما.

## [توابع دورة الحياة](/docs/state-and-lifecycle.html#adding-lifecycle-methods-to-a-class) {#lifecycle-methods}

توابع دورة الحياة هي عبارة عن وظيفة مخصصة تُنفَّذ خلال أطوار مختلفة من حياة المكوّن. هنالك توابع متوفرة عند إنشاء وإدخال المكوّن إلى DOM (الوصل)، وعند تحديث المكوّن، وعند فصل المكوّن أو إزالته من DOM.

 ## [المكوّنات المضبوطة](/docs/forms.html#controlled-components) و. [المكوّنات غير المضبوطة](/docs/uncontrolled-components.html)

تمتلك React طريقتين مختلفتين عند التعامل مع حقول الإدخال.

يُدعى عنصر حقل الإدخال الذي تكون قيمته مضبوطة من قبل React بالمكوّن المضبوط. عندما يُدخِل المستخدم البيانات إلى المكوّن المضبوط يُطلَق مُعالِج لحدث التغيير وتُقرِّر الشيفرة لديك ما إذا كانت الإدخالات صالحة (عن طريق إعادة التصيير مع القيمة المُحدَّثة). إن لم تُعِد التصيير فسيبقى عنصر حقل الإدخال بدون تغيير.

يُدعى عنصر حقل الإدخال الذي تكون قيمته مضبوطة من قبل React بالمكوّن المضبوط. عندما يُدخِل المستخدم البيانات إلى المكوّن المضبوط يُطلَق مُعالِج لحدث التغيير وتُقرِّر الشيفرة لديك ما إذا كانت الإدخالات صالحة (عن طريق إعادة التصيير مع القيمة المُحدَّثة). إن لم تُعِد التصيير فسيبقى عنصر حقل الإدخال بدون تغيير.

يجب عليك في معظم الحالات استخدام المكوّن المضبوطة.

## [المفاتيح](/docs/lists-and-keys.html) {#keys}

المفتاح هو خاصيّة مميزة وسلسلة نصيّة تحتاج إلى تضمينها عند إنشاء عناصر من المصفوفات. تُساعِد المفاتيح React بالتعرّف على العناصر التي تغيّرت أو أُضيفت أو أُزيلت. يجب إعطاء المفاتيح للعناصر الموجودة بداخل مصفوفة لإعطاء العناصر هويّة مستقرّة.

يجب أن تكون المفاتيح فريدة فقط ضمن العناصر الأشقاء بنفس المصفوفة، فلا يجب عليها أن تكون فريدة في كامل التطبيق أو حتى في مكوّن واحد.

لا تُمرِّر شيئًا مثل التابع `Math.random()‎` للمفاتيح. من الهام أن تمتلك المفاتيح هويات مستقرة خلال إعادة التصيير لكي تتمكّن React من تحديد وقت إضافة أو إزالة أو إعادة ترتيب العناصر. يجب أن تتوافق المفاتيح مع مُعرِّفات مستقرة وفريدة قادمة من بياناتك، مثل `post.id`.

## [المراجع](/docs/refs-and-the-dom.html) {#refs}

تدعم React خاصيّة فريدة تستطيع ربطها إلى أي مكوّن. يُمكِن أن تكون الخاصيّة `ref` عبارة عن مكوّن ناشئ عن الدالة[`React.createRef()` function](/docs/react-api.html#reactcreateref) أو دالة رد نداء، أو سلسلة نصيّة (في واجهة برمجة التطبيق القديمة). عندما تكون خاصيّة المرجع `ref` عبارة عن دالة نداء فستستقبل الدالة عنصر DOM الموافق أو نسخة من الصنف (بناءً على نوع العنصر) كوسيط له. يسمح هذا بامتلاك وصول مباشر إلى عنصر DOM أو نسخة المكوّن.

استخدم المراجع بحذر. إن وجدت نفسك تستخدمها كثيرًا لتنفيذ الأشياء في تطبيقك فانظر في إمكانيّة تآلفك مع [تدفق البيانات من الأعلى للأسفل](/docs/lifting-state-up.html).

## [الأحداث](/docs/handling-events.html) {#events}

تمتلك معالجة الأحداث في عناصر React بعض الفروق في الصياغة:

* تُسمَّى مُعالجات أحداث React بالشكل camelCase بدلًا من الأحرف الصغيرة.
* تُمرِّر في JSX الدالة كمعالج للأحداث بدلًا من تمرير سلسلة نصيّة.

## [المطابقة](/docs/reconciliation.html) {#reconciliation}

عندما تتغيّر حالة أو خاصيّات المكوّن، تُقرِّر React ما إذا كان تحديث DOM ضروريًّا عن طريق مقارنة العنصر المُعاد حديثًا مع المُصيَّر سابقًا. وعندما لا يكونان متساويان تُحدِّث React نموذج DOM. تُدعى هذه العمليّة بالمُطابَقَة (reconciliation).
